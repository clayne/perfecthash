/*++

Copyright (c) 2023-2024 Trent Nelson <trent@trent.me>

Module Name:

    Chm01FileWorkCMakeListsTextFile.c

Abstract:

    This module implements the prepare file work callback routine for the
    CMakeLists.txt file as part of the CHM v1 algorithm implementation for
    the perfect hash library.

--*/

#include "stdafx.h"
#include "CMakeLists_Text_RawCString.h"

_Use_decl_annotations_
HRESULT
PrepareCMakeListsTextFileChm01(
    PPERFECT_HASH_CONTEXT Context,
    PFILE_WORK_ITEM Item
    )
{
    PRTL Rtl;
    PCHAR Base;
    PCHAR Output;
    ULONG NumberOfSeeds;
    PCSTRING Name;
    PCSTRING Upper;
    BOOLEAN IncludeKeys;
    PPERFECT_HASH_KEYS Keys;
    PPERFECT_HASH_PATH Path;
    PPERFECT_HASH_FILE File;
    PPERFECT_HASH_DIRECTORY ParentDirectory;
    PPERFECT_HASH_TABLE Table;
    PTABLE_INFO_ON_DISK TableInfoOnDisk;

    //
    // Initialize aliases.
    //

    Rtl = Context->Rtl;
    Table = Context->Table;
    Keys = Table->Keys;
    File = *Item->FilePointer;
    ParentDirectory = File->ParentDirectory;
    Path = ParentDirectory->Path;
    Name = &Path->TableNameA;
    Upper = &Path->TableNameUpperA;
    TableInfoOnDisk = Table->TableInfoOnDisk;
    NumberOfSeeds = TableInfoOnDisk->NumberOfSeeds;
    IncludeKeys = (Table->TableCreateFlags.IncludeKeysInCompiledDll != FALSE);

    Base = (PCHAR)File->BaseAddress;
    Output = Base;

    //
    // Write the CMakeLists.txt file.
    //

    OUTPUT_RAW("# CMakeLists.txt: Auto-generated by Perfect Hash.\n");
    OUTPUT_RAW("# https://github.com/tpn/perfecthash\n");
    OUTPUT_RAW("#\n\n");
    OUTPUT_RAW("cmake_minimum_required(VERSION 3.10)\n\n");

    OUTPUT_RAW("project(");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(")\n\n");

    OUTPUT_RAW("include_directories(..)\n");
    OUTPUT_RAW("include_directories(${CMAKE_CURRENT_SOURCE_DIR})\n\n");

    OUTPUT_RAW("set(PCH_HEADER ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("_StdAfx.h)\n");

    OUTPUT_RAW("set(PCH_SOURCE ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("_StdAfx.c)\n\n");

    OUTPUT_RAW("add_library(");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(" SHARED\n");

    //
    // Four-space indented filename with suffix.
    //

#define OUTPUT_FILE4(Suffix) \
    OUTPUT_RAW("    ");     \
    OUTPUT_STRING(Name);    \
    OUTPUT_RAW(Suffix);     \
    OUTPUT_RAW("\n");

    //
    // Eight-space indented filename with suffix.
    //

#define OUTPUT_FILE8(Suffix) \
    OUTPUT_RAW("        ");     \
    OUTPUT_STRING(Name);    \
    OUTPUT_RAW(Suffix);     \
    OUTPUT_RAW("\n");

    OUTPUT_FILE4(".c");
    OUTPUT_FILE4("_TableValues.c");
    OUTPUT_FILE4("_TableData.c");
    if (IncludeKeys) {
        OUTPUT_FILE4("_Keys.c");
    }
    OUTPUT_RAW("    ${PCH_SOURCE}\n");
    OUTPUT_RAW(")\n\n");

    OUTPUT_RAW("if(WIN32)\n");
    OUTPUT_RAW("    target_sources(");
    OUTPUT_STRING(Name);
    OUTPUT_RAW(" PRIVATE\n");
    OUTPUT_RAW("        ${PCH_HEADER}\n");
    OUTPUT_FILE8(".def");
    OUTPUT_RAW("    )\n");
    OUTPUT_RAW("endif()\n\n");

    //
    // Test executable.
    //

    OUTPUT_RAW("add_executable(Test_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_FILE4("_Support.c");
    OUTPUT_FILE4("_Keys.c");
    OUTPUT_FILE4("_Test.c");
    OUTPUT_FILE4("_TestExe.c");
    OUTPUT_RAW(")\n\n");
    OUTPUT_RAW("target_link_libraries(Test_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n    ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n)\n\n");

    //
    // BenchmarkIndex executable.
    //

    OUTPUT_RAW("add_executable(BenchmarkIndex_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_FILE4("_Support.c");
    OUTPUT_FILE4("_Keys.c");
    OUTPUT_FILE4("_BenchmarkIndex.c");
    OUTPUT_FILE4("_BenchmarkIndexExe.c");
    OUTPUT_RAW(")\n\n");
    OUTPUT_RAW("target_link_libraries(BenchmarkIndex_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n    ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n)\n\n");

    //
    // BenchmarkFull executable.
    //

    OUTPUT_RAW("add_executable(BenchmarkFull_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n");
    OUTPUT_FILE4("_Support.c");
    OUTPUT_FILE4("_Keys.c");
    OUTPUT_FILE4("_BenchmarkFull.c");
    OUTPUT_FILE4("_BenchmarkFullExe.c");
    OUTPUT_RAW(")\n\n");
    OUTPUT_RAW("target_link_libraries(BenchmarkFull_");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n    ");
    OUTPUT_STRING(Name);
    OUTPUT_RAW("\n)\n\n");

    //
    // We're done, update number of bytes written and finish up.
    //

    File->NumberOfBytesWritten.QuadPart = RtlPointerToOffset(Base, Output);

    return S_OK;
}

// vim:set ts=8 sw=4 sts=4 tw=80 expandtab                                     :
